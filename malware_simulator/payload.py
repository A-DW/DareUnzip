import os # os is a module that provides a portable way of using operating system dependent functionality like reading or writing to the file system.
import time # time is a module that provides various time-related functions.
import platform # platform is a module that provides information about the Python runtime environment.
import psutil # psutil is a cross-platform library for retrieving information on running processes and system utilization (CPU, memory, disks, network, sensors) in Python.
import locale # locale is a module that provides access to the POSIX locale database and functionality for internationalization.
import ctypes # ctypes required for using GetTickCount64()
import ifaddr

# This is the payload file.
banner = """
###########################
# Hello from the payload! #
###########################-----------------------------------+
| This is a simple payload that simulates malicious activity. |
+-------------------------------------------------------------+
"""
print(banner)

# Prints a message indicating the payload is running.
print("The payload is now executing...")

##################################################################
#                                                                #
#         OS Module: What's this Operating System (OS)?          #
#                                                                #
##################################################################
# Checks what's the current OS in order to states compatibility. #
##################################################################

# Checks the machine's Operating System and prints it.
print("Detecting the operating system...\n\n" + "-" * 50 + "\n")
time.sleep(1)  # Simulate a delay for effect

# It is important to know the OS for compatibility with the payload.
# We could use 'os.name' to identify the OS type, however it will provide a very basic output:
# For example, it will return 'nt' for Windows and 'posix' for Unix-like systems (e.g. Linux, macOS and BSD).
# In order to get more detailed information, we can use 'platform.system()' which gives us a more specific OS name (while not providing as much detail as 'platform.platform()').
operating_system = platform.system()
time.sleep(1)  # Simulate a delay for effect

# Print the detected OS. This is useful for debugging and understanding the environment.
print("Detected Operating System:", operating_system)

supported = False # Start with the assumption that the OS is not supported.

if operating_system == "Windows":
    print("Windows OS detected.") # If this was a real payload, we might use Windows-specific commands or libraries.
    supported = True  # Set supported to True since we are on a Windows machine.
    time.sleep(1)  # Simulate a delay for effect
elif operating_system == "Linux":
    print("Linux OS detected. Checking for vulnerabilities...") # If this was a real payload, we might use Linux-specific commands or libraries.
    time.sleep(1)  # Simulate a delay for effect
    os_info = {}
    # /etc/os-release is tha standard way to get distribution information on modern Linux systems.
    # The payload will try to parse it to ensure we're on a supported distribution
    try:
        with open("/etc/os-release", "r") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split('=',1)
                    os_info[key.strip()] = value.strip().strip('"')
    except FileNotFoundError:
        # if /etc/os-release doesn't exist, we can't verify the distribution.
        print("Could not find /etc/os-release. Unable to verify Linux distribution.")
        exit(0)  # Terminate the script since it does not perform any actions on unsupported distributions.

    distro_id = os_info.get('ID', '').lower()
    id_like = os_info.get('ID_LIKE', '').lower()

    # The payload is targeting Ubuntu and Debian-based distributions.
    if distro_id == 'ubuntu' or 'debian' in id_like.split():
        pretty_name = os_info.get('PRETTY_NAME', 'a Debian-based distribution')
        print(f"Compatible distribution detected: {pretty_name}.")
        supported = True
    else:
        # If the distribution is not supported, we print a message and exit.
        if os_info:
            pretty_name = os_info.get('PRETTY_NAME', 'this distribution')
            print(f"Unsupported Linux distribution: {pretty_name}")
            exit(0)  # Terminate the script since it does not perform any actions on unsupported distributions.

elif operating_system == "Darwin":
    print("macOS detected.") # If this was a real payload, we might use macOS-specific commands or libraries.
    print("Note: This payload does not perform any actions or supported on macOS. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on macOS.
elif operating_system == "FreeBSD":
    print("FreeBSD OS detected.") # If this was a real payload, we might use FreeBSD-specific commands or libraries.
    print("Note: This payload does not perform any actions or supported on FreeBSD. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on FreeBSD.
else:
    print("Unknown OS detected.") # In this case, the OS could be the various BSDs or other less common systems.
    print("Note: This payload does not perform any actions or supported on unknown OSes. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on unknown OSes.

# ATTENTION: This script DOES NOT perform anything on the BSD family, macOS or other OSes, so it will terminate!

################################################################################################
#                                                                                              #
#                     Reconnaissance Module: System Information Gathering                      #
#                                                                                              #
################################################################################################
# The following section gathers various system information that could be useful for a payload: #
# - Start a simple payload that simulates a malicious action.                                  #
# - This could be anything from opening a reverse shell to exfiltrating data.                  #
# - Get the system's hostname.                                                                 #
# - Get the machine users, and the in-use user.                                                #
# - Get the system's timezone and time.                                                        #
# - Get the system's locale settings.                                                          #
# - Get the system's uptime.                                                                   #
# - Get the system's network interfaces.                                                       #
# - Get the MAC address of the machine.                                                        #
# - Get the IP address of the machine, along with the Wi-Fi's SSID connected.                  #
# - Get the system's architecture.                                                             #
# - Get the system's kernel version.                                                           #
# - Get the system's CPU architecture, usage and information.                                  #
# - Get the system's memory usage and information.                                             #
# - Get the system's disk usage and information.                                               #
# - Get the system's running processes and their information.                                  #
# - Get the system's environment variables.                                                    #
# - Get the system's firewall rules.                                                           #
################################################################################################

# Start a simple payload that simulates a malicious action.
# This could be anything from opening a reverse shell to exfiltrating data.
print("-" * 50 + "\n#### Simulating malicious activity... ####\n" + "-" * 50 + "\n")
time.sleep(1)  # Simulate a delay for effect

# Initialize variables to hold system information
hostname, user, all_users, user_in_use, os_name, architecture, timezone, locale_settings, uptime, interfaces, mac, ip, wifi_ssid, kernel_version, cpu, cpu_usage, memory, memory_usage, disk, disk_usage, processes, environment, network, firewall = ('N/A',) * 24

# --- Reconnaissance (works on both Windows and Linux) ---
print("Gathering system information...\n")
time.sleep(1)  # Simulate a delay for effect

# Machine Hostname
hostname = platform.node()

# All machine users
all_users = psutil.users() # Get all users logged in
all_users_str = "\n".join([f"{user.name}, Terminal: {user.terminal}, Host: {user.host}, Started: {user.started}" for user in all_users])

# In-use user
user_in_use = os.getlogin()

# Timezone
timezone = time.tzname[time.daylight]

# Locale settings
locale_settings = locale.getlocale()

# Gather MAC Addresses from psutil for each interface
mac = {}
for interface, addrs in psutil.net_if_addrs().items():
    for addr in addrs:
        # AF_LINK for most systems, AF_PACKET for Linux
        if getattr(addr, 'family', None) == psutil.AF_LINK or getattr(psutil, 'AF_POCKET0', None):
            mac[interface] = addr.address

# Network interfaces
ip_list = [] # Initializes as empty list
mac_addresses = list(mac.values()) # List of MAC addresses in order of arrival
mac_index = 0

adapters = ifaddr.get_adapters() # Get all network adapters
for adapter in adapters:
    # Network adapter name
    net_adapter = f"Network Adapter: {adapter.nice_name}"
    ip_list.append(net_adapter)

    # Takes the next MAC of the list, if there is one
    if mac_index < len(mac_addresses):
        mac_address = mac_addresses[mac_index]
        mac_index += 1
    else:
        mac_address = 'N/A'
    mac_str = f"   MAC Address: {mac_address}"
    ip_list.append(mac_str)  # Collecting MAC addresses

    for ip in adapter.ips:
        # IP address
        ip_str = f"   {ip.ip}/{ip.network_prefix}"
        ip_list.append(ip_str)  # Collecting IP addresses
        
# Adapters & IP Addresses & MAC Addresses
interfaces = f"{net_adapter}\n{ip_str}\n{mac_str}" # Adapter name and IP/MAC addresses

ips = "\n   ".join(ip_list)

# OS
os_name = operating_system # Use a differente variable name to avoid shadowing the 'os' module

# Architecture
architecture = platform.machine()

# Kernel version
kernel_version = platform.release()

# CPU architecture, usage and information
cpu = platform.processor()

# Environment variables 
environment = os.environ.get('PATH', 'N/A') # Example: get PATH env var

try:
    user = os.getlogin()
except OSError:
    user = 'N/A' # os.getlogin() can fail in some non-interactive environments

if operating_system == "Windows":
    print("Performing Windows-specific reconnaissance...")
    # Uptime
    lib = ctypes.windll.kernel32 # getting the library in which GetTickCount64() resides
    t = lib.GetTickCount64() # calling the funcion and storing the return value
    t = int(str(t)[:-3]) # since the time is in milliseconds (e.g. 1000 * seconds); therefore truncating the value
    # extracting hours, minutes, seconds % days from 't' variable (which store total time in seconds
    mins, sec = divmod(t, 60)
    hours, mins = divmod(mins, 60)
    days, hours = divmod(hours, 24)
    # formatting the time in readable form (format = x days, HH:MM:SS)
    uptime = f"{days} days, {hours:02}:{mins:02}:{sec:02}"

    # TODO: Add Windows-specific reconnaissance code here
    # Example:
    # ip = ...
    # firewall = ...

elif operating_system == "Linux":
    # This check is technically redundant because we already verified it,
    # but it helps structure the code clearly
    if 'os_info' in locals():
        distro_id = os_info.get('ID', '').lower()
        id_like = os_info.get('ID_LIKE', '').lower()
        if distro_id == 'ubuntu' or 'debian' in id_like.split():
            print("Performing Ubuntu-specific reconnaissance...")
            # Uptime
            t = os.popen('uptime -p').read()[:-1] # sending the uptime command as an argument to popen() and saving the returned result (after truncating the trailing \n)
            uptime = t
            # TODO: Add Linux-specific reconnaissance code here
            # Example:
            # ip = ...
            # firewall = ...

# Machine Hostname -> W/U 
# All machine users -> W/U
# In-use user -> W/U
# Timezone -> W/U
# Locale settings -> W/U
# Uptime -> W/U
# Network interfaces -> 
# MAC address -> 
# IP address and Wi-Fi SSID connected -> 
# OS -> W/U
# Architecture -> W/U
# Kernel version -> W/U
# CPU architecture, usage and information -> W/U
# Memory usage and information -> 
# Disk usage and information -> 
# Running processes and their information -> 
# Environment variables -> W/U
# Firewall rules -> 

attention = """
#############
# Attention #
#############
"""
print(attention)

show_mac = False
see_mac = input("The MAC Address Information is not currently properly working. Do you want to see MAC Addresses Information? (y/n)")
while True:
    if see_mac.lower() == "y":
        show_mac = True
        break
    elif see_mac.lower() == "n":
        show_mac = False
        break
    else:
        print("Invalid input. Please enter 'y' or 'n'.")
        see_mac = input("The MAC Address Information is not currently properly working. Do you want to see MAC Addresses Information? (y/n)")
        continue

time.sleep(0.5)  # Simulate a delay for effect

print("+-----------------------------------+")
print("|        SYSTEM INFORMATION         |")
print("+----------------+------------------+")
print(f"| Hostname       | {hostname:<20}|")
print(f"| In-Use User    | {user_in_use:<20}|")
print(f"| All Users      | {all_users_str:<20}|")
print(f"| Timezone       | {timezone:<20}|")
print(f"| Locale         | {str(locale_settings):<20}|")
print(f"| Uptime         | {uptime:<20}|")
print(f"| Interfaces     | {interfaces:<20}|")
if show_mac == True:
    mac_display = "\n".join(mac_addresses)
    print(f"| MAC Addresses  | {mac_display:<20}|")
print(f"| MAC Address    | {str(mac):<20}|")
print(f"| IP Address     | {ips:<20}|")
print(f"| Wi-Fi SSID     | {wifi_ssid:<20}|")
print(f"| OS             | {os_name:<20}|")
print(f"| Architecture   | {architecture:<20}|")
print(f"| Kernel Version | {kernel_version:<20}|")
print(f"| CPU            | {cpu:<20}|")
print(f"| CPU Usage      | {cpu_usage:<20}|")
print(f"| Memory         | {memory:<20}|")
print(f"| Memory Usage   | {memory_usage:<20}|")
print(f"| Disk           | {disk:<20}|")
print(f"| Disk Usage     | {disk_usage:<20}|")
print(f"| Processes      | {processes:<20}|")
print(f"| Environment    | {environment:<20}|")
print(f"| Network        | {network:<20}|")
print(f"| Firewall       | {firewall:<20}|")
print("+----------------+------------------+")


print("\nPayload execution completed. Exiting...\n")
time.sleep(1)  # Simulate a delay for effect