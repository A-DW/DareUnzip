import os # os is a module that provides a portable way of using operating system dependent functionality like reading or writing to the file system.
import time # time is a module that provides various time-related functions.
import platform # platform is a module that provides information about the Python runtime environment.
import datetime # datetime is needed for uptime calculation
import psutil # psutil is a cross-platform library for retrieving information on running processes and system utilization (CPU, memory, disks, network, sensors) in Python.
import locale # locale is a module that provides access to the POSIX locale database and functionality for internationalization.
import ctypes # ctypes required for using GetTickCount64()
import socket # socket is needed for network address family constants

# This is the payload file.
banner = """
##############################
# The payload says: "Hello!" #
##############################--------------------------------+
| This is a simple payload that simulates malicious activity. |
+-------------------------------------------------------------+
"""
print(banner)

# Prints a message indicating the payload is running.
print("The payload is now executing...")

##################################################################
#                                                                #
#         OS Module: What's this Operating System (OS)?          #
#                                                                #
##################################################################
# Checks what's the current OS in order to states compatibility. #
##################################################################

# Checks the machine's Operating System and prints it.
print("Detecting the operating system...\n\n" + "-" * 50 + "\n")
time.sleep(1)  # Simulate a delay for effect

# It is important to know the OS for compatibility with the payload.
# We could use 'os.name' to identify the OS type, however it will provide a very basic output:
# For example, it will return 'nt' for Windows and 'posix' for Unix-like systems (e.g. Linux, macOS and BSD).
# In order to get more detailed information, we can use 'platform.system()' which gives us a more specific OS name (while not providing as much detail as 'platform.platform()').
operating_system = platform.system()
time.sleep(1)  # Simulate a delay for effect

# Print the detected OS. This is useful for debugging and understanding the environment.
print("Detected Operating System:", operating_system)

supported = False # Start with the assumption that the OS is not supported.

if operating_system == "Windows":
    print("Windows OS detected.") # If this was a real payload, we might use Windows-specific commands or libraries.
    supported = True  # Set supported to True since we are on a Windows machine.
    time.sleep(1)  # Simulate a delay for effect
elif operating_system == "Linux":
    print("Linux OS detected. Checking for vulnerabilities...") # If this was a real payload, we might use Linux-specific commands or libraries.
    time.sleep(1)  # Simulate a delay for effect
    os_info = {}
    # /etc/os-release is tha standard way to get distribution information on modern Linux systems.
    # The payload will try to parse it to ensure we're on a supported distribution
    try:
        with open("/etc/os-release", "r") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split('=',1)
                    os_info[key.strip()] = value.strip().strip('"')
    except FileNotFoundError:
        # if /etc/os-release doesn't exist, we can't verify the distribution.
        print("Could not find /etc/os-release. Unable to verify Linux distribution.")
        exit(0)  # Terminate the script since it does not perform any actions on unsupported distributions.

    distro_id = os_info.get('ID', '').lower()
    id_like = os_info.get('ID_LIKE', '').lower()

    # The payload is targeting Ubuntu and Debian-based distributions.
    if distro_id == 'ubuntu' or 'debian' in id_like.split():
        pretty_name = os_info.get('PRETTY_NAME', 'a Debian-based distribution')
        print(f"Compatible distribution detected: {pretty_name}.")
        supported = True
    else:
        # If the distribution is not supported, we print a message and exit.
        if os_info:
            pretty_name = os_info.get('PRETTY_NAME', 'this distribution')
            print(f"Unsupported Linux distribution: {pretty_name}")
            exit(0)  # Terminate the script since it does not perform any actions on unsupported distributions.

elif operating_system == "Darwin":
    print("macOS detected.") # If this was a real payload, we might use macOS-specific commands or libraries.
    print("Note: This payload does not perform any actions or supported on macOS. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on macOS.
elif operating_system == "FreeBSD":
    print("FreeBSD OS detected.") # If this was a real payload, we might use FreeBSD-specific commands or libraries.
    print("Note: This payload does not perform any actions or supported on FreeBSD. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on FreeBSD.
else:
    print("Unknown OS detected.") # In this case, the OS could be the various BSDs or other less common systems.
    print("Note: This payload does not perform any actions or supported on unknown OSes. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on unknown OSes.

# ATTENTION: This script DOES NOT perform anything on the BSD family, macOS or other OSes, so it will terminate!

################################################################################################
#                                                                                              #
#                     Reconnaissance Module: System Information Gathering                      #
#                                                                                              #
################################################################################################
# The following section gathers various system information that could be useful for a payload: #
# - Hostname, current user, and all logged-in users.                                           #
# - OS version, architecture, and kernel version.                                              #
# - System uptime, timezone, and locale settings.                                              #
# - CPU model and current usage.                                                               #
# - Total and used memory.                                                                     #
# - Disk partitions and their usage.                                                           #
# - A list of the top 10 running processes by memory.                                          #
# - Network interface details, including IP and MAC addresses.                                 #
# - The current PATH environment variable.                                                     #
#                                                                                              #
# The following are planned but not yet implemented:                                           #
# - Wi-Fi SSID.                                                                                #
# - Detailed network connection information (netstat).                                         #
# - Firewall rules.                                                                            #
################################################################################################

# Start a simple payload that simulates a malicious action.
# This could be anything from opening a reverse shell to exfiltrating data.
print("\n" + "-" * 50 + "\n#### Simulating malicious activity... ####\n" + "-" * 50 + "\n")
time.sleep(1)  # Simulate a delay for effect

# Initialize variables to hold system information
hostname, all_users_str, user_in_use, os_name, architecture, timezone, locale_settings, uptime, interfaces, ip, wifi_ssid, kernel_version, cpu, cpu_usage, memory, disk, processes, environment, network, firewall = ('N/A',) * 20

# --- Reconnaissance (works on both Windows and Linux) ---
print("Gathering system information...\n")
time.sleep(1)  # Simulate a delay for effect

# Machine Hostname
hostname = platform.node()

# All machine users
all_users = psutil.users() # Get all users logged in
all_users_str = ", ".join([user.name for user in all_users])

# In-use user
user_in_use = os.getlogin()

# Timezone
timezone = time.tzname[time.daylight]

# Locale settings
locale_settings = locale.getlocale()

# Uptime (Cross-platform)
try:
    boot_time_timestamp = psutil.boot_time()
    uptime_seconds = time.time() - boot_time_timestamp
    uptime_delta = datetime.timedelta(seconds=uptime_seconds)
    days = uptime_delta.days
    hours, remainder = divmod(uptime_delta.seconds, 3600)
    minutes, seconds = divmod(remainder, 60)
    uptime = f"{days} days, {hours:02}:{minutes:02}:{int(seconds):02}"
except Exception as e:
    uptime = f"Could not calculate uptime: {e}"
    
# --- Network Interfaces, IP Addresses, and MAC Addresses ---
# Using psutil for a unified and more reliable approach. This replaces the
# previous implementation that used both psutil and the 'ifaddr' library.
interface_info_list = []
all_ips_list = []
mac = {} # Re-initialize as we will populate it here

try:
    net_if_addrs = psutil.net_if_addrs()
    for interface_name, interface_addresses in net_if_addrs.items():
        # Skip loopback interfaces as they are not usually relevant for external communication
        if "lo" in interface_name.lower() or "loopback" in interface_name.lower():
            continue

        mac_address = 'N/A'
        ipv4_addresses = []
        for address in interface_addresses:
            if address.family == psutil.AF_LINK:
                mac_address = address.address
            elif address.family == socket.AF_INET:
                ipv4_addresses.append(address.address)

        # Only include interfaces that have a MAC or IP address for relevance
        if mac_address != 'N/A' or ipv4_addresses:
            mac[interface_name] = mac_address
            all_ips_list.extend(ipv4_addresses)
            interface_info_list.append(f"Adapter: {interface_name}, MAC: {mac_address}, IPs: {', '.join(ipv4_addresses) or 'N/A'}")

except Exception as e:
    interface_info_list.append(f"Could not get network info: {e}")

interfaces = "\n".join(interface_info_list) if interface_info_list else "No active interfaces found."
ips = ", ".join(all_ips_list) if all_ips_list else "N/A"

# OS
os_name = operating_system # Use a differente variable name to avoid shadowing the 'os' module

# Architecture
architecture = platform.machine()

# Kernel version
kernel_version = platform.release()

# CPU architecture, usage and information
cpu = platform.processor()
cpu_usage = f"{psutil.cpu_percent(interval=1)}%"  # Get CPU usage percentage

# Memory usage and information
mem = psutil.virtual_memory()
memory = f"Total: {mem.total / (1024 ** 3):.2f} GB, Used: {mem.used / (1024 ** 3):.2f} GB, Free: {mem.free / (1024 ** 3):.2f} GB"

# Disk usage and information
disk_info_list = []
try:
    partitions = psutil.disk_partitions(all=False)  # Get all disk partitions
    for partition in partitions:
        try:
            usage = psutil.disk_usage(partition.mountpoint)
            disk_info_list.append(
                f"(Device: {partition.device} ({partition.fstype}) on {partition.mountpoint}), "
                f"Total: {usage.total / (1024 ** 3):.2f} GB, "
                f"Used: {usage.used / (1024 ** 3):.2f} GB ({usage.percent}%)"
            )
        except (PermissionError, FileNotFoundError):
            # If we can't access the partition, we skip it
            disk_info_list.append(f"(Device: {partition.device}, Mountpoint: {partition.mountpoint}, Access Denied)")
    disk = "\n".join(disk_info_list) if disk_info_list else "No Disk Information Available"
except Exception as e:
    disk = f"Error retrieving disk information: {str(e)}"

# Running processes and their information
process_list = []
# Get a list of running processes, sorted by memory usage and take the top 10
try:
    procs = sorted(psutil.process_iter(['pid', 'name', 'username', 'memory_info']),
                   key=lambda p: p.info['memory_info'].rss if p.info.get('memory_info') else 0, reverse=True)
    for p in procs[:10]: # Limit to top 10 processes for readability
        try:
            mem_mb = p.info['memory_info'].rss / (1024 * 1024) if p.info.get('memory_info') else 0
            process_list.append(f"PID: {p.info['pid']:<6} Mem: {mem_mb:6.1f}MB   User: {p.info.get('username', 'N/A'):<15.15}   Name: {p.info['name']}")
        except (psutil.NoSuchProcess, psutil.AccessDenied, TypeError):
            continue # Skip processes that have terminated or are inaccessible
    processes = "\n".join(process_list) if process_list else "Could not retrieve process list."
except Exception as e:
    processes = f"Error retrieving process information: {str(e)}"

# Environment variables
try:
    env_list = []
    # Limit to the first 15 for readability, as the full list
    for i, (key, value) in enumerate(os.environ.items()):
        if i >= 15:
            env_list.append("... and more")
            break
        # To avoid breaking the table, truncate long variables
        if len(value) > 70:
            value = value[:70] + "..."
        env_list.append(f"{key} = {value}")
    environment = "\n".join(env_list) if env_list else "No environment variables found."
except Exception as e:
    environment = f"Could not retrieve environment variables: {e}"

if operating_system == "Windows":
    print("Performing Windows-specific reconnaissance...")

    # TODO: Add Windows-specific reconnaissance code here (e.g., firewall status, wifi ssid)
    wifi_ssid = "N/A (TODO)"

elif operating_system == "Linux":
    # This check is technically redundant because we already verified it,
    # but it helps structure the code clearly
    if 'os_info' in locals():
        distro_id = os_info.get('ID', '').lower()
        id_like = os_info.get('ID_LIKE', '').lower()
        if distro_id == 'ubuntu' or 'debian' in id_like.split():
            print("Performing Ubuntu-specific reconnaissance...")
            
            # TODO: Add Linux-specific reconnaissance code here (e.g., firewall status, wifi ssid)
            wifi_ssid = "N/A (TODO)"

# --- Status of Reconnaissance Tasks ---
# W/U = Works on Windows/Unix-like
# TODO = Not yet implemented

# Machine Hostname: W/U
# All machine users: W/U
# In-use user: W/U
# Timezone: W/U
# Locale settings: W/U
# Uptime: W/U
# Network interfaces: W/U
# MAC address: W/U
# IP address: W/U
# Wi-Fi SSID: TODO
# OS, Architecture, Kernel: W/U
# CPU info and usage: W/U
# Memory usage: W/U
# Disk usage: W/U
# Running processes: W/U
# Environment variables: W/U
# Firewall rules: TODO

time.sleep(0.5)  # Simulate a delay for effect

# For cleaner printing, let's create a dictionary to hold the info
info = {
    "Hostname": hostname,
    "In-Use User": user_in_use,
    "All Users": all_users_str,
    "Timezone": timezone,
    "Locale": str(locale_settings),
    "Uptime": uptime,
    "Interfaces": interfaces,
    "IP Addresses": ips,
    "Wi-Fi SSID": wifi_ssid,
    "OS": os_name,
    "Architecture": architecture,
    "Kernel Version": kernel_version,
    "CPU": cpu,
    "CPU Usage": cpu_usage,
    "Memory": memory,
    "Disk": disk,
    "Processes": processes,
    "Environment": environment,
    "Network": network,
    "Firewall": firewall
}

sys_info = """
+-----------------+-----------------------------------------------------------+
|                   SYSTEM INFORMATION GATHERED                   |
+-----------------+-----------------------------------------------------------+
"""
for key, value in info.items():
    # Convert value to string to handle lists/None, then split for multi-line values
    lines = str(value).split('\n')
    # Print the first line with the key
    end_lines = len(lines)-1
    # If it's the table's last line, dont put '\n' at the end of the last line and put sys_info
    # If this is not done, it will appear a line in blank between the last system information parameter and the table closing line
    if key == list(info.keys())[-1]:
        sys_info += f"| {key:<15} | {lines[0]:<100} |"
        if end_lines == 0: break
        else:
            continue
    sys_info += f"| {key:<15} | {lines[0]:<100} |\n"
    # Print subsequent lines indented
    for line in lines[1:]:
        sys_info += f"| {'':<15} | {line.strip():<100} |\n"
sys_info += "\n+-----------------+-----------------------------------------------------------+\n"

print(sys_info)

print("Payload execution completed. Exiting...\n")
time.sleep(1)  # Simulate a delay for effect