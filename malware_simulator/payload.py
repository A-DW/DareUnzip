import os # os is a module that provides a portable way of using operating system dependent functionality like reading or writing to the file system.
import time # time is a module that provides various time-related functions.
import platform # platform is a module that provides information about the Python runtime environment.
import datetime # datetime is needed for uptime calculation
import psutil # psutil is a cross-platform library for retrieving information on running processes and system utilization (CPU, memory, disks, network, sensors) in Python.
import locale # locale is a module that provides access to the POSIX locale database and functionality for internationalization.
import socket # socket is needed for network address family constants
import subprocess # subprocess is needed for executing shell commands

# This is the payload file.
banner = """
##############################
# The payload says: "Hello!" #
##############################--------------------------------+
| This is a simple payload that simulates malicious activity. |
+-------------------------------------------------------------+
"""
print(banner)

# Prints a message indicating the payload is running.
print("The payload is now executing...")

##################################################################
#                                                                #
#         OS Module: What's this Operating System (OS)?          #
#                                                                #
##################################################################
# Checks what's the current OS in order to states compatibility. #
##################################################################

# Checks the machine's Operating System and prints it.
print("Detecting the operating system...\n\n" + "-" * 50 + "\n")
time.sleep(1)  # Simulate a delay for effect

# It is important to know the OS for compatibility with the payload.
# We could use 'os.name' to identify the OS type, however it will provide a very basic output:
# For example, it will return 'nt' for Windows and 'posix' for Unix-like systems (e.g. Linux, macOS and BSD).
# In order to get more detailed information, we can use 'platform.system()' which gives us a more specific OS name (while not providing as much detail as 'platform.platform()').
operating_system = platform.system()
time.sleep(1)  # Simulate a delay for effect

# Print the detected OS. This is useful for debugging and understanding the environment.
print("Detected Operating System:", operating_system)

supported = False # Start with the assumption that the OS is not supported.

if operating_system == "Windows":
    print("Windows OS detected.") # If this was a real payload, we might use Windows-specific commands or libraries.
    supported = True  # Set supported to True since we are on a Windows machine.
    time.sleep(1)  # Simulate a delay for effect
elif operating_system == "Linux":
    print("Linux OS detected.") # If this was a real payload, we might use Linux-specific commands or libraries.
    time.sleep(1)  # Simulate a delay for effect
    os_info = {}
    # /etc/os-release is tha standard way to get distribution information on modern Linux systems.
    # The payload will try to parse it to ensure we're on a supported distribution
    try:
        with open("/etc/os-release", "r") as f:
            for line in f:
                if "=" in line:
                    key, value = line.strip().split('=',1)
                    os_info[key.strip()] = value.strip().strip('"')
    except FileNotFoundError:
        # if /etc/os-release doesn't exist, we can't verify the distribution.
        print("Could not find /etc/os-release. Unable to verify Linux distribution.")
        exit(0)  # Terminate the script since it does not perform any actions on unsupported distributions.

    distro_id = os_info.get('ID', '').lower()
    id_like = os_info.get('ID_LIKE', '').lower()

    # The payload is targeting Ubuntu and Debian-based distributions.
    if distro_id == 'ubuntu' or 'debian' in id_like.split():
        pretty_name = os_info.get('PRETTY_NAME', 'a Debian-based distribution')
        print(f"Compatible distribution detected: {pretty_name}.")
        supported = True
    else:
        # If the distribution is not supported, we print a message and exit.
        if os_info:
            pretty_name = os_info.get('PRETTY_NAME', 'this distribution')
            print(f"Unsupported Linux distribution: {pretty_name}")
            exit(0)  # Terminate the script since it does not perform any actions on unsupported distributions.

elif operating_system == "Darwin":
    print("macOS detected.") # If this was a real payload, we might use macOS-specific commands or libraries.
    print("Note: This payload does not perform any actions or supported on macOS. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on macOS.
elif operating_system == "FreeBSD":
    print("FreeBSD OS detected.") # If this was a real payload, we might use FreeBSD-specific commands or libraries.
    print("Note: This payload does not perform any actions or supported on FreeBSD. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on FreeBSD.
else:
    print("Unknown OS detected.") # In this case, the OS could be the various BSDs or other less common systems.
    print("Note: This payload does not perform any actions or supported on unknown OSes. Consider going into a Windows or Ubuntu machine.")
    exit(0) # Terminate the script since it does not perform any actions on unknown OSes.

# ATTENTION: This script DOES NOT perform anything on the BSD family, macOS or other OSes, so it will terminate!

################################################################################################
#                                                                                              #
#                     Reconnaissance Module: System Information Gathering                      #
#                                                                                              #
################################################################################################
# The following section gathers various system information that could be useful for a payload: #
# - Hostname, current user, and all logged-in users.                                           #
# - OS version, architecture, and kernel version.                                              #
# - System uptime, timezone, and locale settings.                                              #
# - CPU model and current usage.                                                               #
# - Total and used memory.                                                                     #
# - Disk partitions and their usage.                                                           #
# - A list of the top 10 running processes by memory.                                          #
# - Network interface details, including IP and MAC addresses.                                 #
# - The current PATH environment variable.                                                     #
#                                                                                              #
# The following are planned but not yet implemented:                                           #
# - Wi-Fi SSID.                                                                                #
# - Detailed network connection information (netstat).                                         #
# - Firewall rules.                                                                            #
################################################################################################

# Start a simple payload that simulates a malicious action.
# This could be anything from opening a reverse shell to exfiltrating data.
print("\n" + "-" * 50 + "\n#### Simulating malicious activity... ####\n" + "-" * 50 + "\n")
time.sleep(1)  # Simulate a delay for effect

# --- Reconnaissance (works on both Windows and Linux) ---
print("Gathering system information...\n")
time.sleep(1)  # Simulate a delay for effect

# Machine Hostname
def get_hostname():
    hostname = platform.node()
    return hostname

# All machine users
def get_all_users():
    all_users = psutil.users()  # Get all users logged in
    return ", ".join([user.name for user in all_users])

# In-use user
def get_user_in_use():
    return os.getlogin()

# Timezone
def get_timezone():
    return time.tzname[time.daylight]

# Locale settings
def get_locale():
    return locale.getlocale()

# Uptime (Cross-platform)
def get_uptime():
    try:
        boot_time_timestamp = psutil.boot_time()
        uptime_seconds = time.time() - boot_time_timestamp
        uptime_delta = datetime.timedelta(seconds=uptime_seconds)
        days = uptime_delta.days
        hours, remainder = divmod(uptime_delta.seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        return f"{days} days, {hours:02}:{minutes:02}:{int(seconds):02}"
    except Exception as e:
        return f"Could not calculate uptime: {e}"

# Network Interfaces
def get_network_interfaces():
    interface_info_list = []
    try:
        net_if_addrs = psutil.net_if_addrs()
        mac = {}
        all_ips_list = []
        for interface_name, interface_addresses in net_if_addrs.items():
            # Skip loopback interfaces as they are not usually relevant for external communication
            if "lo" in interface_name.lower() or "loopback" in interface_name.lower():
                continue
            # Get MAC address and IP addresses
            mac_address = 'N/A'
            ipv4_addresses = []
            for address in interface_addresses:
                if address.family == psutil.AF_LINK:
                    mac_address = address.address
                elif address.family == socket.AF_INET:
                    ipv4_addresses.append(address.address)
            # Only include interfaces that have a MAC or IP address for relevance
            if mac_address != 'N/A' or ipv4_addresses:
                mac[interface_name] = mac_address
                all_ips_list.extend(ipv4_addresses)
                interface_info_list.append(f"Adapter: {interface_name}, MAC: {mac_address}, IPs: {', '.join(ipv4_addresses) or 'N/A'}")
    except Exception as e:
        interface_info_list.append(f"Could not get network info: {e}")
    return "\n".join(interface_info_list) if interface_info_list else "No active interfaces found."

# Get IP Addresses
def get_ip_addresses():
    all_ips_list = []
    try:
        net_if_addrs = psutil.net_if_addrs()
        for interface_name, interface_addresses in net_if_addrs.items():
            # Skip loopback interfaces as they are not usually relevant for external communication
            if "lo" in interface_name.lower() or "loopback" in interface_name.lower():
                continue
            for address in interface_addresses:
                if address.family == socket.AF_INET:
                    all_ips_list.append(address.address)
    except Exception as e:
        all_ips_list.append(f"Could not get IP addresses: {e}")
    return ", ".join(all_ips_list) if all_ips_list else "No active IP addresses found."

# OS Information
def get_os_name():
    os_name = operating_system # Use a differente variable name to avoid shadowing the 'os' module
    return os_name

# Architecture
def get_architecture():
    architecture = platform.machine()
    return architecture

# Kernel version
def get_kernel_version():
    kernel_version = platform.release()
    return kernel_version

# CPU architecture, usage and information
def get_cpu_info():
    cpu = platform.processor()
    cpu_usage = f"{psutil.cpu_percent(interval=1)}%"  # Get CPU usage percentage
    return cpu, cpu_usage

# Memory usage and information
def get_memory_info():
    mem = psutil.virtual_memory()
    memory = f"Total: {mem.total / (1024 ** 3):.2f} GB, Used: {mem.used / (1024 ** 3):.2f} GB, Free: {mem.free / (1024 ** 3):.2f} GB"
    return memory

# Disk usage and information
def get_disk_info():
    disk_info_list = []
    try:
        partitions = psutil.disk_partitions(all=False)  # Get all disk partitions
        for partition in partitions:
            try:
                usage = psutil.disk_usage(partition.mountpoint)
                disk_info_list.append(
                    f"(Device: {partition.device} ({partition.fstype}) on {partition.mountpoint}), "
                    f"Total: {usage.total / (1024 ** 3):.2f} GB, "
                    f"Used: {usage.used / (1024 ** 3):.2f} GB ({usage.percent}%)"
                )
            except (PermissionError, FileNotFoundError):
                # If we can't access the partition, we skip it
                disk_info_list.append(f"(Device: {partition.device}, Mountpoint: {partition.mountpoint}, Access Denied)")
        return "\n".join(disk_info_list) if disk_info_list else "No Disk Information Available"
    except Exception as e:
        return f"Error retrieving disk information: {str(e)}"

# Running processes and their information
def get_processes_info():
    process_list = []
    # Get a list of running processes, sorted by memory usage and take the top 10
    try:
        procs = sorted(psutil.process_iter(['pid', 'name', 'username', 'memory_info']),
                    key=lambda p: p.info['memory_info'].rss if p.info.get('memory_info') else 0, reverse=True)
        for p in procs[:10]: # Limit to top 10 processes for readability
            try:
                mem_mb = p.info['memory_info'].rss / (1024 * 1024) if p.info.get('memory_info') else 0
                process_list.append(
                    f"PID: {p.info['pid']:<6} Mem: {mem_mb:6.1f}MB   User: {p.info.get('username', 'N/A'):<15.15}   Name: {p.info['name']}"
                )
            except (psutil.NoSuchProcess, psutil.AccessDenied, TypeError):
                continue # Skip processes that have terminated or are inaccessible
        return "\n".join(process_list) if process_list else "Could not retrieve process list."
    except Exception as e:
        return f"Error retrieving process information: {str(e)}"

# Environment variables
def get_env_info():
    try:
        env_list = []
        # Limit to the first 15 for readability, as the full list
        for i, (key, value) in enumerate(os.environ.items()):
            if i >= 15:
                env_list.append("... and more")
                break
            # To avoid breaking the table, truncate long variables
            if len(value) > 70:
                value = value[:70] + "..."
            env_list.append(f"{key} = {value}")
        environment = "\n".join(env_list) if env_list else "No environment variables found."
        return environment
    except Exception as e:
        environment = f"Could not retrieve environment variables: {e}"
        return environment

# Network information
# Define a function to format network information
def get_network_info():
    network_info = psutil.net_if_addrs()
    lines = []
    for iface, addrs in network_info.items():
        lines.append(f"{iface}:")
        for addr in addrs:
            if addr.family == psutil.AF_LINK:
                addr_type = "MAC"
            elif addr.family == socket.AF_INET:
                addr_type = "IPv4"
            elif addr.family == socket.AF_INET6:
                addr_type = "IPv6"
            else:
                addr_type = str(addr.family)
            netmask_str = f" (netmask: {addr.netmask})" if addr.netmask else ""
            # Show a line only with relevant information
            #iface_line += f"\n    {addr_type}: {addr.address}{netmask_str}"
            lines.append(f"-> {addr_type}: {addr.address}{netmask_str}")
    return "\n".join(lines) if lines else "No Network Information Available"

# Firewall information
def get_firewall():
    try:
        if operating_system == "Windows":
            result = subprocess.run(['netsh', 'advfirewall', 'show', 'allprofiles'], capture_output=True, text=True)
            return "Enabled" if "Status: active" in result.stdout else "Disabled"
        elif operating_system == "Linux":
            result = subprocess.run(['ufw', 'status'], capture_output=True, text=True)
            return "Enabled" if "Status: active" in result.stdout else "Disabled"
        else:
            return "Not Available"

    except Exception as e:
        return f"Could not retrieve firewall information: {e}"

# Get firewall information
firewall = get_firewall()

# Wifi/Ethernet information
def get_connection():
    wifi_ssid = "N/A"
    ethernet_ssid = "N/A"
    try:
        # Windows-specific
        if operating_system == "Windows":
            # Wi-Fi information
            result = subprocess.run(['netsh', 'wlan', 'show', 'interfaces'], capture_output=True, text=True)
            # Check if the command was successful
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if line.strip().startswith("SSID") and ":" in line:
                        wifi_ssid = line.split(":", 1)[1].strip()
                        break
            # Ethernet information
            result = subprocess.run(['netsh', 'interface', 'show', 'interface'], capture_output=True, text=True)
            # Check if the command was successful
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if "Ethernet" in line and ":" in line:
                        ethernet_ssid = line.split(":", 1)[1].strip()
                        break
        # Linux-specific
        if operating_system == "Linux":
            # Wi-Fi information
            result = subprocess.run(['iwgetid', '-r'], capture_output=True, text=True)
            # Check if the command was successful
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if "SSID" in line and ":" in line:
                        wifi_ssid = line.split(":", 1)[1].strip()
                        break
            # Ethernet information
            result = subprocess.run(['ip', 'addr'], capture_output=True, text=True)
            # Check if the command was successful
            if result.returncode == 0:
                for line in result.stdout.splitlines():
                    if "Ethernet" in line and ":" in line:
                        ethernet_ssid = line.split(":", 1)[1].strip()
                        break
    except Exception as e:
        wifi_ssid = f"Could not retrieve Wi-Fi information: {e}"
        ethernet_ssid = f"Could not retrieve Ethernet information: {e}"        
    return wifi_ssid, ethernet_ssid

# Get Wi-Fi/Ethernet information
wifi_ssid, ethernet_ssid = get_connection()

# --- OS-Specific Reconnaissance ---
if operating_system == "Windows":
    print("Performing Windows-specific reconnaissance...")

elif operating_system == "Linux":
    # This check is technically redundant because we already verified it,
    # but it helps structure the code clearly
    if 'os_info' in locals():
        distro_id = os_info.get('ID', '').lower()
        id_like = os_info.get('ID_LIKE', '').lower()
        if distro_id == 'ubuntu' or 'debian' in id_like.split():
            print("Performing Ubuntu-specific reconnaissance...")

time.sleep(0.5)  # Simulate a delay for effect

# Call all functions and put their results into the info dictionary
def main():
    # Define all variables
    global hostname, user_in_use, all_users_str, timezone, locale_settings, uptime, interfaces, ips, ssid, os_name, architecture, firewall

    # Get basic system information

    # Hostname
    hostname = get_hostname()
    # In-Use User
    user_in_use = get_user_in_use()
    # All Users
    all_users_str = get_all_users()
    # Timezone
    timezone = get_timezone()
    # Locale
    locale_settings = get_locale()
    # Uptime
    uptime = get_uptime()
    # Network Interfaces
    interfaces = get_network_interfaces()
    # IP Addresses
    ips = get_ip_addresses()
    # Wi-Fi/Ethernet SSID
    ssid = get_connection()
    # OS Name
    os_name = get_os_name()
    # Architecture
    architecture = get_architecture()
    # Kernel Version
    kernel_version = get_kernel_version()
    # CPU Information & Usage
    cpu, cpu_usage = get_cpu_info()
    # Memory
    memory = get_memory_info()
    # Disk
    disk = get_disk_info()
    # Processes
    processes = get_processes_info()
    # Environment
    environment = get_env_info()
    # Network
    network = get_network_info()
    # Firewall Status
    firewall = get_firewall()

    # For cleaner printing, let's create a dictionary to hold the info
    info = {
        "Hostname": hostname,
        "In-Use User": user_in_use,
        "All Users": all_users_str,
        "Timezone": timezone,
        "Locale": str(locale_settings),
        "Uptime": uptime,
        "Interfaces": interfaces,
        "IP Addresses": ips,
        "SSID": f"Wi-Fi: {ssid[0]}\nEthernet: {ssid[1]}",
        "OS": os_name,
        "Architecture": architecture,
        "Kernel Version": kernel_version,
        "CPU": cpu,
        "CPU Usage": cpu_usage,
        "Memory": memory,
        "Disk": disk,
        "Processes": processes,
        "Environment": environment,
        "Network": network,
        "Firewall": firewall
    }

    sys_info = "+--------------------+------------------------------------------------------------------------------------------------------+\n"
    sys_info += "|                                                SYSTEM INFORMATION GATHERED                                                |\n"
    sys_info += "+--------------------+------------------------------------------------------------------------------------------------------+\n"

    for key, value in info.items():
        # Convert value to string to handle lists/None, then split for multi-line values
        lines = str(value).split('\n')
        # Print the first line with the key
        end_lines = len(lines)-1
        # If it's the table's last line, dont put '\n' at the end of the last line and put sys_info
        # If this is not done, it will appear a line in blank between the last system information parameter and the table closing line
        if key == list(info.keys())[-1]:
            sys_info += f"| {key:<18} | {lines[0]:<100} |"
            if end_lines == 0: break
            else:
                continue
        sys_info += f"| {key:<18} | {lines[0]:<100} |\n"
        # Print subsequent lines indented
        for line in lines[1:]:
            sys_info += f"| {'':<18} | {line.strip():<100} |\n"
    sys_info += "\n+--------------------+------------------------------------------------------------------------------------------------------+\n"

    print(sys_info)

    print("Payload execution completed. Exiting...\n")
    time.sleep(1)  # Simulate a delay for effect
    exit(0)
    
if __name__ == "__main__":
    main()